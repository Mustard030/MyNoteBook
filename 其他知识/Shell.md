# #1 语法

在Shell文件的首行`#!/bin/bash`声明了系统需要使用bash来执行这段脚本

Shell文件通常以`.sh`为后缀名，但是实际上无需后缀名，这只是约定俗成的命名方式

查看当前使用的Shell解释器类型 

```bash
echo $SHELL
```

`$SHELL`是全局共享的读取解析器类型环境变量，全局环境变量是所有Shell程序都可以读取的变量

```bash
#单行注释

:<<!
# 多行注释1
# 多行注释2
!
```

执行方式：

1. sh解析器执行方式
   - 利用sh命令执行`sh 文件路径`，本质就是使用Shell解析器运行脚本文件
2. bash解析器执行方式
   - 利用bash命令执行`bash 文件路径`
3. 仅路径执行方式
   - `./文件名`直接执行需要文件有可执行权限

区别：直接使用Shell解析器运行脚本文件不需要文件有执行权限，直接执行需要可执行权限



输出数据到文件中的命令

```bash
echo 数据 >> 文件
echo "Hello world" >> /root/hello.txt
```



**Shell中的特殊字符**

[参考文章](https://www.jb51.net/article/120595.htm)

在Shell中，用反引号或者`$()`括起来的式子表示这里不是单纯的字符串，需要执行里面的内容，术语叫做命令替换，即完成引用的命令的执行，将其结果替换出来，与变量替换差不多

例如：

```bash
echo `date '--date=1 hour ago' +%Y-%m-%d-%H`
echo $(date '--date=1 hour ago' +%Y-%m-%d-%H)
```

两种执行结果是一样的，实际使用中更推荐使用`$()`，因为：

1. 反引号与单引号外形相似，容易混淆
2. 在多层次的复合替换中，里层的反引号需要转义处理（\\\`） ，而$()则比较直观
3. 反引号中对于反斜杠有特殊的处理，使用反协议对Shell特殊字符进行转义时需要两个反斜杠，而`$()`中只需要使用一个反斜杠

综上所述， 反引号是一个老的用法，`$()`是新的用法，无论是在学习还是实际工作中，建议使用`$()`



## #1.1 变量

### #1.1.1 环境变量

系统环境变量是系统提供的共享变量，是Linux系统加载Shell的配置文件中定义的变量，共享给所有的Shell程序使用

用户环境变量是仅在当前用户下才可以使用的环境变量，Shell环境加载个人配置文件中定义的变量

1. 全局配置文件（系统级环境变量）
   - `/etc/profile` （核心）
   - `/etc/profile.d/*.sh`
   - `/etc/bashrc`
2. 个人配置文件（用户级环境变量）
   - `当前用户/.bash_profile`
   - `当前用户/.bashrc`

一般情况下都是针对全局配置进行操作



查看当前Shell系统环境变量

```bash
env
```

查看Shell变量（系统环境变量+自定义变量+函数）

```bash
set
```

**常用系统环境变量**

| 变量名称 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| PATH     | 与windows环境变量PATH功能一样，设置命令的搜索路径，以冒号为分割 |
| HOME     | 当前用户的主目录：/root                                      |
| SHELL    | 当前Shell解析器类型：/bin/bash                               |
| HISTFILE | 显示当前用户执行命令的历史列表文件：/root/.bash_history      |
| PWD      | 显示当前所在路径：/root                                      |
| OLDPWD   | 显示之前的路径                                               |
| HOSTNAME | 显示当前主机名                                               |
| HOSTTYPE | 显示主机的架构，如i386、i686、x86、x64等：x86_64             |
| LANG     | 显示当前系统语言环境：zh_CN.UTF-8                            |



**全局配置文件/etc/profile应用场景**

当前用户进入Shell环境初始化的时候会加载全局配置文件/etc/profile里面的环境变量，供给所有Shell程序使用，全局环境变量名建议全大写

```bash
export VAR_NAME=value
```

修改后记得使用`source`命令重载文件



**交互式Shell与非交互式Shell**

交互式Shell：与用户进行交互，用户输入一个命令，Shell环境立刻响应

非交互式Shell：不需要用户参与就可以执行一系列命令，比如一个脚本文件含有多个命令，直接执行并给出结果



**登录Shell与非登录Shell环境**

登录Shell：需要用户名、密码登录的Shell环境

非登录Shell环境：不需要用户名、密码进入的Shell环境，或执行脚本文件

不同的工作环境加载环境变量流程**不一样**

Shell登录环境：

1. 执行`/etc/profile`加载系统环境变量
2. 执行`/etc/profile.d/*.sh`加载系统环境变量
3. **执行`/当前用户/.bash_profile`加载用户环境变量**
4. **执行`/当前用户/.bashrc`加载用户环境变量**
5. 执行`/etc/bashrc`加载系统环境变量

Shell非登录环境：

1. **执行`/当前用户/.bashrc`加载用户环境变量**
2. 执行`/etc/bashrc`加载系统环境变量
3. 执行`/etc/profile.d/*.sh`加载系统环境变量

需要登录的执行的Shell脚本读取的环境变量配置在：`/etc/profile`、`/当前用户/.bash_profile`

不需要登录的用户执行的Shell脚本读取的环境变量配置在：`/当前用户/.bashrc`、`/etc/bashrc`



**使用`$0`识别环境语法**

```bash
echo $0
```

输出`-bash`代表Shell登录环境，输出`bash`代表Shell非登录环境



**切换Shell环境**

有三种方式：

1. 直接登录系统，即为登录环境

2. su切换用户登录

   ```bash
   #切换到指定用户，加载Shell登录环境变量
   su 用户名 --login
   或
   su 用户名 -l
   
   #切换到指定用户，加载Shell非登录环境
   su 用户名
   ```

3. bash切换

```bash
bash #加载Shell非登录环境

sh -l 文件名 #先加载登陆环境，再运行指定Shell文件
bash -l 文件名 #先加载登陆环境，再运行指定Shell文件
```







### #1.1.2 自定义变量

分类：

1. 自定义局部变量
2. 自定义常量
3. 自定义全局变量

Shell脚本中的变量默认是全局的，作用域为从定义的地方开始到脚本结束，如果需要添加一个局部变量，则需要在变量定义前加上`local`关键字如`local num=$1`，`$1`表示函数中的第一个参数



#### 自定义局部变量

就是定义在一个脚本文件中的变量，只能在这个脚本文件中使用

定义：

```bash
var_name=value
var_name='value'
var_name="value" #推荐
```

三种定义方式的区别：

1. 使用单引号的字符串会原样输出，其中使用变量是无效的
2. 双引号方式变量会被解析，并且还可以出现子双引号（需要转义）
3. 没有引号的方式与双引号方式一样可以解析变量，但是不能被空格分割，否则后面会被断开当做其他命令解析

注意：

1. **等号两侧不能有空格！**
2. 在bash环境中，变量默认类型都是字符串类型，无法直接进行数值运算
3. 变量的值如果有空格，则必须使用双引号括起来
4. 不能使用Shell的关键字作为变量名称



查询变量值语法：

```bash
#直接使用变量名
$var_name
#使用花括号(推荐)
${var_name}
#区别：花括号方式适合拼接字符串
#如：
echo my name is ${name}123
```

删除：

```bash
unset var_name
```

如果要定义只在作用域内有效的作用域变量，需要使用local关键字

```bash
local var_name=xxx
```

获取字符串长度：

```bash
${#var_name}
```





#### 自定义常量

定义后不可修改，也叫只读变量

语法：

```bash
var_name=xxx
readonly var_name

var_name=xxx #此时就会报错
```



#### 自定义全局变量

在当前脚本文件中定义全局变量，这个全局变量可以在当前Shell环境和子Shell环境中使用

> **父子Shell环境的概念**
>
> 例如：有两个Shell脚本文件，A.sh和B.sh，如果在A.sh脚本文件中执行了B.sh脚本文件，A.sh就是父Shell环境，B.sh就是子Shell环境



**定义语法：**

```bash
export var_name1 var_name2=xxx ... #可以先定义再export也可以同时赋值，可以一次多个
```





#### 字符串拼接

```bash
var1=abc
var2="hello world"
#无符号拼接
var3=${var1}${var2}  #abchello world
#双引号拼接
var3="${var1}${var2}"  #abchello world
#混合拼接
var3=${var1}'&'${var2}  #abc&hello world
var3="${var1} \"&\" ${var2}"  #abc "&" hello world
```



#### 字符串截取和匹配

| 格式                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| `${变量名:start:length}`   | 若start为正，从字符串左边第start个字符开始，向右截取length个字符，start从0开始<br/>若start为负，从字符串右边第start个字符开始，向右截取length个字符，具体参考下方说明 |
| `${变量名:start}`          | 若start为正，从字符串左边第start个字符开始，向右截取到最后<br/>若start为负，从字符串右边第start个字符开始，向右截取到最后，具体参考下方说明 |
| `${变量名#*chars}`         | 从字符串左边第一次出现\*chars的位置开始，截取\*chars右边的所有字符 |
| `${变量名##*chars}`        | 从字符串左边最后一次出现\*chars的位置开始，截取\*chars右边的所有字符 |
| `${变量名%chars*}`         | 从字符串右边第一次出现chars\*的位置开始，截取chars\*左边的所有字符 |
| `${变量名%%chars*}`        | 从字符串右边最后一次出现chars\*的位置开始，截取chars\*左边的所有字符 |
| `${/var/pattern/pattern}`  | 表示将var字符串的第一个匹配的pattern替换为另一个pattern。不改变原变量。 |
| `${//var/pattern/pattern}` | 表示将var字符串所有匹配的pattern替换为另一个pattern。不改变原变量。 |

```text
  -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 <-
   h  e   l  l  o      w  o  r  l  d
-> 0  1   2  3  4   5  6  7  8  9  10
```

记忆的方法为：

> \#是去掉左边(在键盘上#在$之左边)
> %是去掉右边(在键盘上%在$之右边)
> 一个符号是最小匹配，两个符号是最大匹配。





#### 索引数组变量

Bash Shell只支持一维数组，不支持多维数组



**数组定义**

```bash
array=(item1 item2 ...) #方式一，下标默认从0开始
array=([索引下标1]=item1 [索引下标2]=item2 ...) #方式二,下标为数值，使用declare才能设置k-v型的Array

例：
nums=(29 100 87 "www.baidu.com")
arr[6]=100
arr2=([0]=100 [2]=28 [10]=abc)
```

**获取**

```bash
${array[index]}
item=${array[index]}  #可同时赋值给其他变量

${array[@]} #获取数组中所有元素
${array[*]} #获取数组中所有元素

${#array[@]} #获取数组长度或个数
${#array[*]} #获取数组长度或个数

${#array[index]} #获取指定元素字符长度
```

**拼接**

即数组合并，使用`@`和`*`获取所有元素后进行拼接

```bash
array_new=(${array1[@]} ${array2[@]} ...)
array_new=(${array1[*]} ${array2[*]} ...)
```

**删除**

```bash
unset array_name[index] #删除元素
unset array_name #删除数组
```






### #1.1.3 特殊变量

| 特殊变量 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| $#       | 传递给脚本或函数的位置参数的个数                             |
| $?       | 上一命令的退出状态码或者函数的返回值。每个Shell命令的执行都有返回值，用于说明命令执行是否成功，0通常表示没有错误，非0值表示有错误 |
| $*       | 传递给脚本或函数的位置参数，双引号包围时作为一个整体         |
| $@       | 传递给脚本或函数的位置参数，双引号包围时作为一个列表         |
| $$       | 当前Shell进程的进程ID（PID）                                 |
| $!       | 最后一个后台命令的进程ID                                     |
| $0       | 当前脚本的名称                                               |
| $1-n     | 脚本或函数的传入位置参数，当n>9的时候要用${n}，如${10}       |

**执行脚本文件传入参数语法：**

```bash
sh 脚本文件 参数1 参数2 ...
```

**`$*`和`$@`的区别：**

当不使用双引号括起来时：

- 两者相同，获取所有参数数据为一个字符串，格式为：`$1 $2 ... $n`

当使用双引号括起来时：

- "$*" 获取的所有参数拼接为一个字符串，格式为"$1 $2 ... $n"
- "$@" 获取一组参数列表对象，格式为 "$1" "$2" ... "$n"

使用循环打印所有输入参数可以看出区别

```bash
for var in 列表变量
do 
	循环体
done
```







## #1.2 内置命令

由bash自身提供，而不是文件系统中的可执行脚本文件

使用type来确定一个命令是否为内置命令

```bash
type cd #cd是Shell内嵌
type ifconfig #ifconfig是/usr/sbin/ifconfig
```



### alias

可以对复杂命令设置别名

只输入alias可查看当前设置的所有别名

```bash
alias 别名="命令" #单双引号都可以
unalias 别名 #删除别名
unalias -a #删除当前Shell环境中所有别名
```



### echo

```bash
#默认输出换行语法
echo 字符串
#输出不换行语法
echo -n 字符串
#默认不解析转义字符
echo "hello \nworld" #hello \nworld
#解析转义字符
echo -e "hello \nworld" 
#hello
#world
echo -e "hello world\c" #\c是清除结尾换行符的转义字符
#hello world[root@localhost ~]#
```



### read

读取控制台输入并赋值给变量，如果没有重定向，默认从终端控制台读取用户输入的数据，进行了重定向可以从文件中读取数据

> 语法：
>
> read [-options] [var1 var2 ...]
>
> [-options] [var1 var2 ...]都是可选的，如果没有提供变量名，那么读取的数据会存放到环境变量REPLY中，通过$REPLY获取read最后一个读入命令的数据



**options支持的参数：**

| 选项         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| -a array     | 把读取的数据赋值给数组array，下标0开始                       |
| -d delimiter | 用字符串delimiter指定读取结束的位置，而不是一个换行符（读取到的数据不包括delimiter） |
| -e           | 在获取用户输入的时候，对功能键进行编码转换，不会直接显示功能键对应的字符 |
| -n num       | 读取num个字符，而不是整行字符                                |
| -p prompt    | 显示提示信息，提示内容为prompt                               |
| -r           | 原样读取（RawMode），不把反斜杠字符解释为转义字符            |
| -s           | 静默模式（SlientMode），不会在屏幕上显示输入的字符，当输入密码和其他确认信息时很有必要 |
| -t seconds   | 设置超时时间，单位为秒，用户没有在规定时间内输入完成，read会返回一个非0的退出状态，表示读取失败 |
| -u fd        | 使用文件描述符fd作为输入源，而不是标准输入，类似于重定向     |



```bash
read -p "请输入姓名，年龄，爱好：" name age hobby
echo "姓名${name},年龄${age},爱好${hobby}"
#输入时使用空格隔开，回车结束输入

read -p "确定删除吗？（y/n）" -n 1 flag
echo #相当于换行
echo flag
```



### exit

退出当前Shell环境进程结束运行，并且可以返回一个状态码，一般可以使用`$?`获取退出的状态码

只使用exit默认返回0



### declare

用于声明Shell变量，可用来声明变量并设置变量的属性，可以用来显示Shell函数，若不加上任何参数，则会显示全部的Shell变量与函数（与执行set命令效果相同）

> 语法：
>
> declare \[+/-\][aArxif] [变量名=值]
>
> +/-： "-"可以用来指定变量的属性 "+"则是取消变量所设的属性
>
> a：array，设置为普通索引数组
>
> A：Array，设置为key-value关联数组（关联数组只能用这种方式声明，否则获取值会有问题）
>
> r：readonly，变量设置为只读，也可以使用readonly
>
> x：export，设置为环境变量，同export
>
> i：int，设置为整型变量
>
> f：function，设置为函数变量

示例：

```bash
declare -i age=20 #设置为整型，顺便赋值
age=abc #失败，会设置成默认值0
declare +i age #取消age为整型的限制

declare -a arr=(item1 item2 ...) #普通索引数组
declare -a arr=([索引下标1]=item1 [索引下标2]=item2 ...) #普通索引数组
declare -A arr=([字符串key1]=v1 [字符串key2]=v2 ...) #字符串索引数组
```

对于关联数组，获取指定key的值和获取所有值的方法与普通数组相同

```bash
${关联数组变量名[key]}

${关联数组变量名[*]}
${关联数组变量名[@]}
```







## #1.3 运算符

### #1.3.1 算术运算符

常用的算数运算符有以下，假定a=1，b=2

| 运算符 | 说明 | 举例                                           |
| ------ | ---- | ---------------------------------------------- |
| +      | 加法 | `expr $a + $b` 结果为3                         |
| -      | 减法 | `expr $a - $b` 结果为-1                        |
| *      | 乘法 | `expr $a \* $b` 结果为2，*为特殊字符，需要转义 |
| /      | 除法 | `expr $b / $a` 结果为2                         |
| %      | 取余 | `expr $b % $a` 结果为0                         |
| =      | 赋值 | `a=$b` 将变量b的值赋给a                        |

四则运算中如果使用了()，也要进行转义，如：`\( 1 + 1 \)`



### #1.3.2 比较运算符

#### 整数比较运算符

假定a=1，b=2，为真则返回0，为假则返回1

| 运算符 | 说明           | 举例                  |
| ------ | -------------- | --------------------- |
| -eq    | 判断两数相等   | `[ $a -eq $b ]` 返回1 |
| -ne    | 判断两数不相等 | `[ $a -ne $b ]` 返回0 |
| -gt    | 左大于右       | `[ $a -gt $b ]` 返回1 |
| -lt    | 左小于右       | `[ $a -lt $b ]` 返回0 |
| -ge    | 左大于等于右   | `[ $a -ge $b ]` 返回1 |
| -le    | 左小于等于右   | `[ $a -le $b ]` 返回0 |
| <      |                | `(($a<$b))` 返回0     |
| <=     |                | `(($a<=$b))` 返回0    |
| >      |                | `(($a>$b))` 返回1     |
| >=     |                | `(($a>=$b))` 返回1    |
| ==     |                | `(($a==$b))` 返回1    |
| !=     |                | `(($a!=$b))` 返回0    |

注意语法和运算符，整数比较运算符只支持整数，不支持小数与字符串，除非字符串的值是整数数字。推荐使用`(( ))`语法



#### 字符串比较运算符

比较两个变量，类型可以为数字（整数、小数）与字符串

假定a="abc"，b="def"，为真则返回0，为假则返回1

字符串比较运算符可以使用`[[]]`和`[]`两种方式

| 运算符    | 说明                         | 举例                                                         |
| --------- | ---------------------------- | ------------------------------------------------------------ |
| `==`或`=` | 相等                         | `[ $a == $b ]` 返回1<br/>`[[ $a == $b ]]` 返回1<br/>`[ $a = $b ]` 返回1<br/>`[[ $a = $b ]]` 返回1 |
| `!=`      | 不相等                       | `[ $a != $b ]` 返回0<br/>`[[ $a != $b ]]`返回0               |
| `<`       | 小于，比较两个字符串或者数字 | `[ $a \< $b ]` 返回0<br/>`[[ $a < $b ]]`返回0                |
| `>`       | 大于，比较两个字符串或者数字 | `[ $a \> $b ]` 返回1<br/>`[[ $a > $b ]]`返回1                |
| `-z`      | 检测字符串长度是否为0        | [-z $a]返回1(false)                                          |
| `-n`      | 检测字符串长度是否不为0      | [-n "$a"]返回0(true)                                         |
| `$`       | 检测字符串是否不为空         | [$a] 返回0(true)                                             |

> 字符串比较没有`<=`，可以通过`[[ "a" < "b" || "a" == "b" ]]`



#### `[[]]` 和 `[]` 的区别

**区别1：word splitting的发生**

`[[]]`不发生word splitting

`[]`会发生word splitting

**word splitting介绍**

会将含有空格的字符串进行分拆分割后比较

例：

```bash
a="a"
b="a b c" #b变量含有空格字符串
[[ $a == $b ]]  #使用[[]]正常，返回1，代表不相等
[ $a == $b ] #报错：参数太多
#比较失败，由于b变量进行以空格为分割后进行比较导致的
```

**区别2：转义字符**

`[[]]`对`<`不需要转义，格式为`[[ $a < $b ]]`

`[]`需要对`>`,`<`转义，格式为`[ $a \< $b ]`



==推荐使用`[[ ]]`可以实现数字和字符串比较，并且不需要转义，不会word splitting==



### #1.3.3 布尔运算符

TODO: 看到这里

https://www.bilibili.com/list/watchlater?bvid=BV17T4y1F7WV&oid=927584172&p=33



### #1.3.4 逻辑运算符





### #1.3.5 文件测试运算符







## #1.4 计算命令

### expr命令

expr是evaluate expressions的缩写，译为“求值表达式”。Shell expr是一个功能强大且比较复杂的命令，除了可以实现**整数**计算（小数计算需要使用[bc命令](#bc命令)），还可以结合一些选项进行字符串处理，例如计算字符串长度、字符串匹配、字符串比较、字符串提取等。

> 语法：
>
> expr 算术运算符表达式
>
> 运算符表达式如：1 + 1 加号两边必须有空格，否则会被识别为整个字符串
>
> 计算结果可以赋值给新变量
>
> result=\`expr 算术运算符表达式\`
>
> result=$(expr 算术运算符表达式)







### bc命令



## #1.5 流程控制

### if

范例：

```shell
if condition; then
	要执行的语句
elif condition; then
	要执行的语句
else
	要执行的语句
fi
```

上面的condition可以是[]，[[]]，或者(())：

- []是最基本的条件测试表达式
- [[]]是扩展测试命令，提供了比[]更强大的功能（常用）
- (())是数学表达式，支持常见的+-*/等数学运算

[]左右必须有两个空格如：`if [ 1 -eq 1 ]` 否则语法错误（其他符号也是一样）





## #1.6 函数



## #1.7 重定向



# #2 工具





# #3 例子